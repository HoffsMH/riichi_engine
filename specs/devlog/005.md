# Devlog 005 - Code Points, Bit Shifting, and the First Rendered Tile

**Date:** 2026-02-10

## What Changed
- Renamed `tile_to_utf8` → `tile_to_code_point` (returns `uint32_t` code point, not bytes)
- Created `print_utf8()` that encodes a code point into 4 UTF-8 bytes using bitwise operations
- Added `suit_base[]` lookup array mapping `Suit` enum values to Unicode base code points
- `tile_to_code_point` computes `suit_base[tile->suit] + (tile->value - 1)`
- Fixed suit enum ordering: Unicode has Bamboos (Sou) before Circles (Pin), not the other way around
- Successfully rendered mahjong tiles in the terminal via the full pipeline

## Concepts Learned
- **`uint32_t` over `int`** for code points — C only guarantees `int` is 16 bits; `uint32_t` says exactly what you mean
- **Separate domain logic from encoding** — `tile_to_code_point` (which character?) vs `print_utf8` (how to serialize it?)
- **`static const` vs `#define`** — `static const` has scope, type, and shows up in debuggers; `#define` is just text replacement
- **Enum values as array indices** — a common C pattern; sequential enum values (0, 1, 2...) index directly into arrays, replacing switch/if chains with a single lookup
- **Bitwise operators for UTF-8 encoding**:
  - `&` (AND) masks bits — `code_point & 0x3F` isolates the bottom 6
  - `>>` (right shift) moves bits down — `code_point >> 6` slides bits 6-11 to positions 0-5
  - `|` (OR) combines prefix with payload — `0x80 | chunk` adds the `10` continuation prefix
- **Hex literals** (`0x3F`) — each hex digit = exactly 4 bits, much easier to read for bit work than decimal
- **C declaration syntax** — `[]` goes after the name (`suit_base[]`), not in the type, because declarations mirror usage

## Next Steps
- Move tile display functions to separate `display.c` / `display.h`
- Learn multi-file compilation and header files
- Clean up `main()` — remove debug prints, test multiple tiles systematically
